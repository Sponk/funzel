/* 
 * This file is part of Funzel.
 * Copyright (c) 2022 Yannick Pflanzer.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#pragma once
#include <iterator>
#include <algorithm>

namespace funzel
{

template<
	typename T,
	unsigned int StaticNum = 5,
	typename SizeT = size_t,
	typename Allocator = std::allocator<T>>
class small_vector
{
public:
	typedef T value_type;
	typedef Allocator allocator_type;
	typedef SizeT size_type;
	typedef std::ptrdiff_t difference_type;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	typedef typename std::allocator_traits<Allocator>::pointer pointer;
	typedef typename std::allocator_traits<Allocator>::const_pointer const_pointer;
	typedef pointer iterator;
	typedef const_pointer const_iterator;
	typedef std::reverse_iterator<iterator> reverse_iterator;
	typedef std::reverse_iterator<const_iterator> const_reverse_iterator;

	small_vector() = default;
	
	small_vector(std::initializer_list<T> values)
	{
		resize(values.size());
		std::copy_n(std::make_move_iterator(values.begin()), values.size(), begin());
	}

	small_vector(size_type sz)
	{
		resize(sz);
	}

	small_vector(size_type sz, const T& v)
	{
		resize(sz, v);
	}

	~small_vector()
	{
		clear();
	}

	iterator begin() { return m_data; }
	iterator end() { return m_data + m_size; }
	const_iterator begin() const { return m_data; }
	const_iterator end() const { return m_data + m_size; }
	const_iterator cbegin() const { return m_data; }
	const_iterator cend() const { return m_data + m_size; }

	bool empty() const { return m_size == 0; }
	size_type size() const { return m_size; }
	size_type max_size() const { return m_capacity; }

	void clear()
	{
		if(m_data != &cache[0])
		{
			m_allocator.deallocate(m_data, m_capacity);
			m_data = &cache[0];
		}

		m_size = 0;
		m_capacity = StaticNum;
	}

	iterator insert(iterator pos, const T& value)
	{
		return insert(pos, 1, value);

		// Use an index as the iterators are going to be potentially invalid
		// after ensureSpace
		difference_type idx = pos - m_data;
		ensureSpace();
		
		std::move_backward(begin() + idx, end(), end() + 1);
		m_data[idx] = value;

		m_size++;
		return pos;
	}

	iterator insert(iterator pos, size_type count, const T& value)
	{
		// Use an index as the iterators are going to be potentially invalid
		// after ensureSpace
		difference_type idx = pos - m_data;
		ensureSpace(count);
		
		std::move_backward(begin() + idx, end(), end() + count);
		std::fill_n(begin() + idx, count, value);

		m_size += count;
		return pos;
	}

	template<typename... Args>
	iterator emplace(iterator pos, Args&&... args)
	{
		ensureSpace();
		std::move_backward(pos, end(), end() + 1);
		new (pos) T(args...);

		m_size++;
		return pos;
	}
	
	iterator erase(iterator pos)
	{
		pos->~T();
		std::move(pos + 1, end(), pos);

		m_size--;
		return pos;
	}

	iterator erase(iterator first, iterator last)
	{
		for(iterator i = first; i != last; i++)
		{
			i->~T();
		}

		std::move(last, end(), first);

		m_size -= (last - first);
		return first;
	}

	void push_back(const T& value)
	{
		ensureSpace();
		m_data[m_size] = value;
		m_size++;
	}

	void push_back(T&& value)
	{
		ensureSpace();
		m_data[m_size] = std::move(value);
		m_size++;
	}

	template<typename... Args>
	reference emplace_back(Args&&... args)
	{
		ensureSpace();
		new ((m_data + m_size)) T(args...);
		m_size++;

		return m_data[m_size-1];
	}

	void pop_back()
	{
		if(m_size)
			m_size--;
	}

	void resize(size_type count)
	{
		reserve(count);
		std::fill(end(), end() + count, T());

		m_size = count;
	}

	void reserve(size_type count)
	{
		if(count > m_capacity)
		{
			T* newdata = m_allocator.allocate(count); //new T[count];
			std::copy_n(std::make_move_iterator(m_data), m_size, newdata);

			if(m_data != &cache[0])
				m_allocator.deallocate(m_data, m_capacity);

			m_data = newdata;
			m_capacity = count;
		}
	}

	void resize(size_type count, const value_type& value)
	{
		reserve(count);
		std::fill(end(), end() + count, value);

		m_size = count;
	}

	const_reference operator[](size_type idx) const { return m_data[idx]; }
	reference operator[](size_type idx) { return m_data[idx]; }

	const_reference at(size_type idx) const
	{
		if(idx >= m_size)
			throw std::out_of_range("Index out of bounds error.");
		return m_data[idx];
	}

	reference at(size_type idx)
	{
		if(idx >= m_size)
			throw std::out_of_range("Index out of bounds error.");
		return m_data[idx];
	}

private:

	void ensureSpace(size_type count = 1)
	{
		size_type newCap = m_capacity;
		while(m_size + count > newCap)
		{
			newCap *= 2;
		}

		// Ensure space!
		reserve(newCap);
	}

	SizeT m_size = 0, m_capacity = StaticNum;
	T* m_data = &cache[0];

	Allocator m_allocator;
	T cache[StaticNum];
};

}
